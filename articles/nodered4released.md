[Статті](README.md)

## Випущено версію 4.0

20 June 2024 • [Nick O'Leary](https://twitter.com/knolleary)

Тепер доступний для [інсталяції](https://npmjs.org/package/node-red) Node-RED 4.0. У разі оновлення прочитайте [інструкції з оновлення](http://nodered.org/docs/getting-started/upgrading.html).

Нижче ми висвітлили деякі з основних моментів випуску. Також було зроблено велику кількість внесків спільноти, починаючи від виправлень помилок, функцій, документації та перекладів. Ми не змогли б робити те, що ми робимо, без цих внесків – велика подяка всім, хто причетний.

[Журнал змін](https://github.com/node-red/node-red/releases/tag/4.0.0) містить повний список змін у цьому випуску.

## Node.js 18 або новішої версії

Для Node-RED 4.0 потрібен принаймні Node.js 18. На момент випуску ми рекомендуємо використовувати Node 20 як активний випуск LTS, який продовжуватиме отримувати оновлення до квітня 2026 року.

## Оновлення редактора

### Автозаповнення для вводів `flow`/`global` і `env`

Node-RED уже має просте автозаповнення полів `msg` у редакторі. Тепер ми розширили це, щоб також працювати з контекстними вводами `flow`/`global`, а також типом `env` для доступу до змінних середовища.

![img](https://nodered.org/blog/content/images/2024/06/auto-complete.png)

Це значно спрощує роботу з такими типами властивостей — бути впевненим, що ви використовуєте щось, що існує, а не перемикатися між різними представленнями в редакторі, щоб отримати правильні назви.

У випадку змінних середовища `env` він також показує вам, де було встановлено значення — корисно, коли у вас є вкладені групи та підпотоки, які можуть перевизначати певне значення.

### Налаштування конфігураційних вузлів у Subflows

Це потрібно трохи пояснити. Підпотоки (Subflows) — це спосіб, за допомогою якого Node-RED дозволяє створювати потік і додавати кілька його екземплярів для багаторазового використання у ваших потоках. Наприклад, підпотік може підключатися до брокера MQTT і виконувати стандартну обробку отриманих повідомлень перед їх надсиланням. Потім підпотік може надати набір властивостей, які можна налаштувати для кожного екземпляра. У нашому прикладі це може бути тема, на яку підписаний вузол MQTT.

Однак у цьому прикладі конфігурація брокера вузла MQTT буде прив’язана до того самого вузла конфігурації брокера в кожному екземплярі – і це те, що ми вирішуємо в Node-RED 4.0.

Ми робимо можливим вибирати вузол конфігурації у властивостях підпотоку, щоб кожен екземпляр можна було ще краще налаштувати.

![img](https://nodered.org/blog/content/images/2024/06/subflow-config.png)

Іншим поширеним використанням для цього буде Node-RED Dashboard, яка використовує вузли конфігурації для встановлення розташування віджета. З Node-RED сьогодні ви не можете використовувати вузли дашбоард у підпотоках, оскільки в кінцевому підсумку ви отримуєте кілька копій віджетів, усі упаковані в одну групу. Завдяки цьому оновленню ви зможете налаштувати екземпляр підпотоку, у яку саме групу дашбоард потрібно розмістити його вміст.

### Форматування позначки часу

Вузол Inject надає можливість вставляти позначку часу з перших днів Node-RED. Значення, яке він фактично встановлює, — це кількість мілісекунд після епохи (він же 1 січня 1970 року). Якщо ви звикли працювати з JavaScript, то це цілком нормальний спосіб скоротати час. Однак це не завжди те, що потрібно, і потоки в кінцевому підсумку використовують вузол Function, щоб певним чином переформатувати його.

У версії 4.0 ми додали параметри вибору формату для генерації позначки часу на початку. Тепер форматування часу та дати може мати багато варіантів. Отже, для цього початкового випуску ми зробили це простим, запропонувавши три варіанти:

![img](https://nodered.org/blog/content/images/2024/06/timestamp-formats.png)

- *мілісекунди з епохи* - існуюча опція, лише більш чітко позначена як це

- *YYYY-MM-DDTHH:mm:ss.sssZ* - також відомий як ISO 8601
- *JavaScript Date Object* - стандартний об'єкт Date

Існує можливість дозволити встановлення рядків спеціального формату у вузлі, але ми спочатку подивимося, які відгуки про ці нові параметри.

### Багатокористувацький режим

Ми внесли низку змін, щоб покращити взаємодію з користувачем, коли редактор відкрито кількома людьми одночасно.

Якщо ввімкнути через файл налаштувань, новий багатокористувацький режим дозволяє вам бачити, коли інші користувачі відкривають редактор і де вони знаходяться – яку вкладку вони відкрили та чи редагують вони вузол.

![img](https://nodered.org/blog/content/images/2024/06/multiplayer.png)

Це невеликий крок уперед до довгострокової мети — бачити в реальному часі зміни, які вносять інші користувачі.

Цей новий режим не ввімкнено за умовчанням. Щоб увімкнути його, вам потрібно встановити для властивості `editorTheme.multiplayer.enabled` значення `true` у файлі налаштувань. Ми додали заповнювач у файл налаштувань за умовчанням, але для наявної інсталяції вам потрібно буде додати його самостійно. Ви можете побачити, як/як це має виглядати [тут](https://github.com/node-red/node-red/blob/3075b82792be6f9668376e66fe6cf3fc137902ff/packages/node_modules/node-red/settings.js#L440-L443) .

### Краще керування фоновим розгортанням

У тій самій темі, що й у новому багатокористувацькому режимі, ми також внесли деякі покращення в існуюче керування «фоновим розгортанням» у редакторі. Тут хтось розгортає нові потоки, поки ви зайняті роботою в редакторі.

Раніше ви отримували сповіщення, яке не могли ігнорувати, і вам довелося перервати те, що ви робите, щоб мати справу з цим. Якщо ваш колега був особливо продуктивним і часто робив розгортання, ви щоразу отримували б нову переривання.

У цьому випуску ми зробили сповіщення менш нав’язливими. Він більше не є модальним, тому ви можете продовжувати те, що робили, не вживаючи жодних дій. Ми зробили його тонким, щоб він не заважав, і він сам закривається через короткий проміжок часу. Як і у випадку з подібними сповіщеннями під час виконання, тепер ми також показуємо піктограму попередження в заголовку, якщо було розгортання у фоновому режимі (оскільки це *потрібно* мати справу з часом) — натискання цієї піктограми відображає сповіщення, щоб ви могли вжити заходів, коли ви вирішите .

![img](https://nodered.org/blog/content/images/2024/06/background-deploy.png)

### Покращено перегляд відмінностей для переміщених вузлів

Під час перегляду змін у потоках у результаті розгортання у фоновому режимі або в рамках функції «Проекти» ми тепер виділяємо вузли, які було переміщено окремо до тих, у яких було змінено конфігурацію.

Коли ви зіткнетеся з довгим списком змін, це полегшить виявлення змін, які вас цікавлять.

![img](https://nodered.org/blog/content/images/2024/06/diff-view.png)

### Кращий відгук для користувачів із доступом лише для читання

Раніше, якщо користувач мав доступ лише для читання до редактора, він міг внести зміни та натиснути кнопку розгортання, але на цьому етапі йому було сказано, що він не може вносити зміни.

У цьому випуску кнопка «Розгорнути» тепер відображає значок замка, якщо поточний користувач не має дозволу на впровадження змін. Вони все ще можуть вносити зміни в робочу область, але кнопка розгортання не стане ввімкненою.

![img](https://nodered.org/blog/content/images/2024/06/locked-deploy.png)

### Новий інтерфейс вибору вузла конфігурації

Ми оновили інтерфейс користувача навколо вибору вузла конфігурації, щоб спростити завдання додавання нового вузла конфігурації.

Відгуки нових користувачів показали деяку плутанину щодо того, як додати *другий* вузол конфігурації, коли він уже був вибраний у списку. Тепер поруч із вибором існуючих вузлів є спеціальна кнопка додавання

![img](https://nodered.org/blog/content/images/2024/06/add-config-node.png)

### Інші оновлення

- Менеджер палітри тепер перераховує плагіни, які ви встановили поруч із вузлами.
- Бічна панель «Палітри» тепер запам’ятовує, як ви розгортали або згортали різні категорії

## Runtime

### Швидше розгортання для *великих* потоків

Ми замінили бібліотеку, яку використовуємо для клонування конфігурацій потоку під час виконання. Нова бібліотека швидша та використовує менше пам’яті.

Пришвидшення менш помітний у «типових» потоках, але для тих із вас, у кого *великі* потоки, має бути покращення.

Під час мого тестування конфігурація з кількома сотнями вкладок із кількома сотнями вузлів на кожній, а також деякими підпотоками розгорталася з 8 секунд до трохи більше 1 секунди.

### Оновлено JSONata

Бібліотека JSONata використовується для надання типів `expression` у Node-RED - дійсно потужному способі роботи з об'єктами JSON. У цьому випуску ми оновили до нового основного випуску JSONata, який містить низку покращень продуктивності.

Але він також має кардинальні зміни в тому, як його викликають під капотом. Ми підготувалися до цього в 3.1, додавши велике попередження до журналу, якщо ми коли-небудь помітили, що вузол звертався до нього неправильно. У цьому випуску це попередження стає помилкою.

Враховуючи, що ми не чули багато скарг у випуску 3.1 з цього приводу, або попередження залишилося непоміченим, або це не поширена проблема. Однак на це слід звернути увагу під час оновлення.

### Інші оновлення

- До файлу налаштувань за замовчуванням додано такі параметри конфігурації:
 - `httpAdminCookieOptions` можна використовувати для налаштування параметрів файлів cookie як частини системи автентифікації.
 - `httpStaticCors` можна використовувати для встановлення користувацьких правил спільного використання ресурсів між джерелами для вмісту, який подається за допомогою параметра `httpStatic`
- `node-red --version` тепер повідомляє інформацію про node-red, node.js та ОС без запуску Node-RED.

## Оновлення вузлів

### Кращий вузол CSV

Вузол CSV було капітально перероблено, щоб зробити його більш сумісним зі стандартами. Виявляється, у CSV є ціла купа хитрих граничних випадків, які більшість користувачів не вловлюють, але якби ви їх уразили, ви б застрягли.

Новий вузол відповідає стандарту [RFC4180](https://www.ietf.org/rfc/rfc4180.txt), а також є швидшим – перемагає у всіх.

Існуючі потоки, що використовують вузол CSV, залишатимуться в «застарілому» режимі, доки їх не буде змінено для використання нового аналізатора.

### Оновлена обробка проксі

Обробку проксі у вузлі HTTP Request було оновлено, щоб вирішити низку проблем і забезпечити кращу підтримку різних стандартних змінних середовища, які використовуються для налаштування проксі.

Подробиці в [оригінальному випуску](https://github.com/node-red/node-red/issues/3904) і [запиті на pull](https://github.com/node-red/node- red/pull/4616), який це виправив.

### Інші оновлення

- Вузол TCP - під час скидання, якщо корисного навантаження немає, залишатися відключеним @dceejay
- HTML-вузол: додано параметр для збору атрибутів і вмісту ([#4513](https://github.com/node-red/node-red/pull/4513))
- дозволено вузлу split вказати властивість для розділення та правильно приєднатися до автоматичного приєднання ([#4386](https://github.com/node-red/node-red/pull/4386))
- Виправлено вузол change, щоб повертати логічне значення за запитом ([#4525](https://github.com/node-red/node-red/pull/4525))
- Дозволено msg.reset скинути підключення вузла запиту Tcp у режимі залишатися на зв’язку ([#4406](https://github.com/node-red/node-red/pull/4406))
- Дозволено встановити довжину повідомлення про статус вузла налагодження за допомогою налаштувань ([#4402](https://github.com/node-red/node-red/pull/4402))
- Можливість: додано можливість установлювати заголовки для клієнта WebSocket ([#4436](https://github.com/node-red/node-red/pull/4436))

## Повний журнал змін

Повний набір змін у цьому випуску можна знайти в [журналі змін](https://github.com/node-red/node-red/releases/tag/4.0.0)

Дякуємо всім, хто долучився до цього випуску – ми б не змогли зробити це без вас!

## Спільнота

Як проект із відкритим кодом, ми покладаємося на внесок спільноти. Ми маємо сильну та активну спільноту користувачів, про що добре свідчить діяльність на [форумах](https://discourse.nodered.org). Приємно бачити підтримку, яку спільнота надає одна одній.

Якщо ви зацікавлені зробити внесок у Node-RED, зараз саме час прийти та поспілкуватися з нами на [форумі](https://discourse.nodered.org) або [slack](https:// nodered.org/slack).